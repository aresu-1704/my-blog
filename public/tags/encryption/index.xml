<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Encryption on Kiến thức lập trình</title>
        <link>http://localhost:1313/tags/encryption/</link>
        <description>Recent content in Encryption on Kiến thức lập trình</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>vi-vn</language>
        <lastBuildDate>Mon, 22 Dec 2025 01:20:00 +0700</lastBuildDate><atom:link href="http://localhost:1313/tags/encryption/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Bảo mật mạng trong ứng dụng Java &amp; JavaScript: từ HTTPS đến Man-in-the-Middle</title>
        <link>http://localhost:1313/post/https-mitm-security/</link>
        <pubDate>Mon, 22 Dec 2025 01:20:00 +0700</pubDate>
        
        <guid>http://localhost:1313/post/https-mitm-security/</guid>
        <description>&lt;img src="http://localhost:1313/images/https-security.jpg" alt="Featured image of post Bảo mật mạng trong ứng dụng Java &amp; JavaScript: từ HTTPS đến Man-in-the-Middle" /&gt;&lt;h2 id=&#34;https---hơn-cả-một-chữ-s&#34;&gt;HTTPS - Hơn cả một chữ S
&lt;/h2&gt;&lt;p&gt;Khi mình mới bắt đầu làm web, thường nghĩ HTTPS chỉ là HTTP thêm security, một feature &amp;ldquo;nice to have&amp;rdquo; cho các website ngân hàng hay e-commerce. Website blog cá nhân hay landing page đơn giản dùng HTTP cũng không sao. Nhưng càng đi sâu vào network security, mình mới thấy suy nghĩ đó ngây thơ đến mức nào.&lt;/p&gt;
&lt;p&gt;HTTPS không phải là một protocol riêng biệt. Nó chính là HTTP chạy bên trên một lớp bảo mật gọi là TLS (Transport Layer Security), trước đây gọi là SSL (Secure Sockets Layer). Về bản chất, khi bạn truy cập &lt;code&gt;https://example.com&lt;/code&gt;, trình duyệt không trực tiếp gửi HTTP request lên server. Thay vào đó, nó thiết lập một TLS connection trước, sau đó mới gửi HTTP data qua connection đã được mã hóa này.&lt;/p&gt;
&lt;p&gt;TLS hoạt động ở giữa tầng Transport (TCP) và tầng Application (HTTP). Nó tạo ra một encrypted tunnel cho data flow. Mọi thứ đi qua tunnel này đều được encrypt, từ HTTP headers đến request body, response data, cookies, tokens. Một observer trên network chỉ thấy được encrypted gibberish, không thể đọc được actual content.&lt;/p&gt;
&lt;h2 id=&#34;vì-sao-http-thuần-túy-nguy-hiểm&#34;&gt;Vì sao HTTP thuần túy nguy hiểm
&lt;/h2&gt;&lt;p&gt;HTTP là plaintext protocol. Khi bạn gửi request, mọi thứ được transmit dưới dạng text thuần túy qua network. Username, password, personal data, session tokens - tất cả đều visible cho bất kỳ ai có thể intercept network traffic.&lt;/p&gt;
&lt;p&gt;Hồi còn học đại học, mình từng dùng Wireshark để capture packets trên WiFi của trường. Chỉ trong vài phút, mình có thể thấy dozens of HTTP requests từ các bạn trong lớp. Một website không dùng HTTPS để login, mình thấy rõ username và password trong POST request body. Cookies của Facebook, session IDs của các forums - tất cả đều exposed.&lt;/p&gt;
&lt;p&gt;Điều đáng sợ là không cần phải là hacker để làm điều này. Bất kỳ ai ngồi chung WiFi công cộng với bạn đều có thể capture traffic. Starbucks, sân bay, hotel - những nơi này là goldmine cho attackers. Họ chỉ cần setup một WiFi access point với tên giống WiFi chính thức, đợi users connect vào, và passive capture mọi HTTP traffic.&lt;/p&gt;
&lt;h2 id=&#34;man-in-the-middle-attack---khi-kẻ-thứ-ba-chen-vào&#34;&gt;Man-in-the-Middle attack - Khi kẻ thứ ba chen vào
&lt;/h2&gt;&lt;p&gt;Man-in-the-Middle (MITM) attack còn nguy hiểm hơn passive sniffing. Trong attack này, attacker không chỉ observe traffic mà còn có thể modify nó. Họ đặt mình ở giữa client và server, intercept requests từ client, có thể modify rồi forward đến server. Tương tự, response từ server cũng đi qua attacker trước khi đến client.&lt;/p&gt;
&lt;p&gt;Cách hoạt động cụ thể như thế này. Giả sử bạn đang connect vào &lt;code&gt;http://bank.com&lt;/code&gt;. Request của bạn phải đi qua router, ISP, có thể qua nhiều intermediate hops trước khi đến server. Attacker có thể compromise bất kỳ hop nào trên đường đi này. Khi request đến attacker&amp;rsquo;s machine, họ có full access để đọc và modify.&lt;/p&gt;
&lt;p&gt;Một scenario phổ biến là ARP spoofing trên local network. Attacker gửi fake ARP messages để trick các devices nghĩ rằng attacker&amp;rsquo;s machine là gateway router. Mọi traffic từ victims đều route qua attacker&amp;rsquo;s machine trước. Attacker có thể thay đổi prices trong e-commerce requests, inject malicious scripts vào HTML responses, hoặc đơn giản là steal credentials.&lt;/p&gt;
&lt;p&gt;Với HTTP, không có cách nào để client verify rằng response thực sự đến từ legitimate server. Client gửi request đến IP address, nhận response từ IP đó, và trust response. Nhưng nếu attacker control routing hoặc DNS, họ có thể direct traffic đến fake server của họ. Client không có cách phân biệt.&lt;/p&gt;
&lt;h2 id=&#34;tls-và-certificate-chain-of-trust&#34;&gt;TLS và certificate chain of trust
&lt;/h2&gt;&lt;p&gt;TLS giải quyết vấn đề này thông qua cryptography và certificate authorities. Khi client connect đến HTTPS server, server phải present một digital certificate. Certificate này chứa public key của server và được sign bởi một trusted Certificate Authority (CA).&lt;/p&gt;
&lt;p&gt;Browser có built-in list of trusted CAs. Khi nhận certificate từ server, browser verify signature của CA. Nếu signature valid và CA nằm trong trusted list, browser tin rằng certificate authentic. Lúc này, client và server perform một key exchange protocol (thường là Diffie-Hellman hoặc RSA) để establish một shared secret. Shared secret này dùng để encrypt tất cả subsequent communication.&lt;/p&gt;
&lt;p&gt;Điều quan trọng là attacker không thể forge certificate. Để tạo valid certificate cho &lt;code&gt;bank.com&lt;/code&gt;, họ cần private key của một CA. Nhưng CAs protect private keys của họ vô cùng nghiêm ngặt. Nếu một CA bị compromise, modern browsers sẽ revoke trust đối với CA đó.&lt;/p&gt;
&lt;p&gt;Ngay cả khi attacker có thể intercept TLS traffic, họ chỉ thấy encrypted data. Không có private key của server, họ không thể decrypt. Nếu họ cố modify encrypted data, integrity checks sẽ fail và connection bị terminate. Client sẽ thấy error thay vì receive corrupted data.&lt;/p&gt;
&lt;h2 id=&#34;https-trong-java-server-applications&#34;&gt;HTTPS trong Java server applications
&lt;/h2&gt;&lt;p&gt;Khi develop Java backend, enable TLS là một phần thiết yếu của production setup. Java sử dụng keystores để manage certificates và private keys. Keystore là một encrypted file chứa certificates và keys, protected bởi password.&lt;/p&gt;
&lt;p&gt;Để setup HTTPS trong Java application server như Tomcat, bạn cần generate hoặc obtain một certificate. Trong development, bạn có thể tự generate self-signed certificate bằng keytool:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;keytool -genkeypair -alias myserver -keyalg RSA -keysize &lt;span style=&#34;color:#ae81ff&#34;&gt;2048&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -validity &lt;span style=&#34;color:#ae81ff&#34;&gt;365&lt;/span&gt; -keystore keystore.jks -storepass changeit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Command này tạo một RSA key pair và self-signed certificate, store chúng trong &lt;code&gt;keystore.jks&lt;/code&gt;. Trong production, thay vì self-signed cert, bạn sẽ request certificate từ một trusted CA như Let&amp;rsquo;s Encrypt, DigiCert, hoặc Comodo.&lt;/p&gt;
&lt;p&gt;Configure Tomcat để use keystore:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Connector&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;port=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;8443&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;protocol=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.apache.coyote.http11.Http11NioProtocol&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           &lt;span style=&#34;color:#a6e22e&#34;&gt;maxThreads=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;150&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SSLEnabled=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SSLHostConfig&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Certificate&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;certificateKeystoreFile=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;conf/keystore.jks&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#a6e22e&#34;&gt;certificateKeystorePassword=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;changeit&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#a6e22e&#34;&gt;type=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;RSA&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SSLHostConfig&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Connector&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Với Spring Boot, configuration còn đơn giản hơn trong &lt;code&gt;application.properties&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.port&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.ssl.key-store&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;classpath:keystore.jks&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.ssl.key-store-password&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;changeit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.ssl.key-store-type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;JKS&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.ssl.key-alias&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;myserver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Khi server start, Java&amp;rsquo;s SSL/TLS implementation (JSSE - Java Secure Socket Extension) handle toàn bộ TLS handshake, encryption và decryption. Application code của bạn không cần biết gì về underlying encryption. Bạn vẫn đọc request và gửi response như bình thường, JSSE transparent encrypt/decrypt ở phía dưới.&lt;/p&gt;
&lt;p&gt;Một best practice quan trọng là force HTTPS redirect. Nếu user accidentally access &lt;code&gt;http://example.com&lt;/code&gt;, server nên redirect đến &lt;code&gt;https://example.com&lt;/code&gt;. Trong Spring Security:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Configuration&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SecurityConfig&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; WebSecurityConfigurerAdapter {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;configure&lt;/span&gt;(HttpSecurity http) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        http.&lt;span style=&#34;color:#a6e22e&#34;&gt;requiresChannel&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .&lt;span style=&#34;color:#a6e22e&#34;&gt;anyRequest&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .&lt;span style=&#34;color:#a6e22e&#34;&gt;requiresSecure&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// Force HTTPS&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;javascript-và-browser-security-restrictions&#34;&gt;JavaScript và browser security restrictions
&lt;/h2&gt;&lt;p&gt;Phía client, JavaScript trong browser cũng có những restrictions nghiêm ngặt liên quan đến HTTPS. Modern browsers implement nhiều security features chỉ available khi page được serve qua HTTPS.&lt;/p&gt;
&lt;p&gt;Service Workers, một technology cho Progressive Web Apps và offline functionality, hoàn toàn require HTTPS. Browser không cho register service workers từ HTTP pages (except localhost cho development). Lý do là service workers có quyền intercept network requests và modify responses. Nếu attacker có thể inject malicious service worker qua HTTP, họ có thể control toàn bộ subsequent requests của user.&lt;/p&gt;
&lt;p&gt;Geolocation API, camera và microphone access, clipboard API, payment request API - tất cả đều require HTTPS. Browser không muốn sensitive permissions này được grant cho potentially insecure pages. Nếu page được serve qua HTTP, attacker có thể modify JavaScript để abuse những permissions này.&lt;/p&gt;
&lt;p&gt;Cookies với flag &lt;code&gt;Secure&lt;/code&gt; chỉ được gửi qua HTTPS connections. Đây là cách protect session cookies khỏi being stolen qua HTTP. Khi set cookie:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;document.&lt;span style=&#34;color:#a6e22e&#34;&gt;cookie&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sessionId=abc123; Secure; HttpOnly; SameSite=Strict&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Flag &lt;code&gt;Secure&lt;/code&gt; ensure rằng ngay cả khi user accidentally truy cập HTTP version của site, session cookie sẽ không được gửi. &lt;code&gt;HttpOnly&lt;/code&gt; prevent JavaScript access (protect khỏi XSS), và &lt;code&gt;SameSite=Strict&lt;/code&gt; prevent cookie được gửi trong cross-site requests (protect khỏi CSRF).&lt;/p&gt;
&lt;p&gt;HTTP Strict Transport Security (HSTS) là một mechanism mà server có thể tell browser &amp;ldquo;luôn luôn dùng HTTPS cho domain này&amp;rdquo;. Server gửi header:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Strict-Transport-Security: max-age=31536000; includeSubDomains
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Browser sẽ remember directive này trong 31536000 seconds (1 năm). Trong thời gian đó, mọi attempt truy cập HTTP version sẽ automatically redirect sang HTTPS ngay ở browser, không cần round-trip đến server. Điều này prevent một loại MITM attack gọi là SSL stripping, where attacker downgrade HTTPS connections sang HTTP.&lt;/p&gt;
&lt;h2 id=&#34;mixed-content-và-browser-warnings&#34;&gt;Mixed content và browser warnings
&lt;/h2&gt;&lt;p&gt;Một vấn đề phổ biến khi migrate từ HTTP sang HTTPS là mixed content. Nếu HTTPS page load resources (scripts, stylesheets, images) qua HTTP, browser sẽ block hoặc warn. Lý do là ngay cả khi main page secure, HTTP resources có thể bị modified bởi attacker, compromise toàn bộ page.&lt;/p&gt;
&lt;p&gt;Ví dụ, nếu HTTPS page include:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://cdn.example.com/jquery.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Browser sẽ block script này. Attacker có thể MITM connection đến CDN và inject malicious code vào jQuery. Dù main page được deliver securely, injected script có full access để steal data.&lt;/p&gt;
&lt;p&gt;Modern browsers classify mixed content thành hai loại. Passive mixed content (images, audio, video) được load nhưng có warning. Active mixed content (scripts, stylesheets, fonts) bị block hoàn toàn. Để fix, bạn phải đảm bảo tất cả resources loaded qua HTTPS hoặc use protocol-relative URLs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;//cdn.example.com/jquery.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Protocol-relative URLs inherit protocol của parent page. Nếu page là HTTPS, resource cũng được load qua HTTPS.&lt;/p&gt;
&lt;h2 id=&#34;certificate-validation-và-trust-issues&#34;&gt;Certificate validation và trust issues
&lt;/h2&gt;&lt;p&gt;Mặc dù TLS provide strong security, nó rely on certificate validation. Nếu client không properly validate certificates, security bị compromise. Một mistake phổ biến trong Java code là disable certificate validation trong development rồi quên enable lại trong production.&lt;/p&gt;
&lt;p&gt;Mình từng thấy code như này trong production:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// DANGER: Disable certificate validation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TrustManager&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; trustAllCerts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TrustManager&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; X509TrustManager() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; X509Certificate&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getAcceptedIssuers&lt;/span&gt;() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkClientTrusted&lt;/span&gt;(X509Certificate&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; certs, String authType) {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkServerTrusted&lt;/span&gt;(X509Certificate&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; certs, String authType) {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SSLContext sc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SSLContext.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SSL&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sc.&lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;, trustAllCerts, &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; java.&lt;span style=&#34;color:#a6e22e&#34;&gt;security&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SecureRandom&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HttpsURLConnection.&lt;span style=&#34;color:#a6e22e&#34;&gt;setDefaultSSLSocketFactory&lt;/span&gt;(sc.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSocketFactory&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Code này accept bất kỳ certificate nào, kể cả self-signed hay expired certs. Điều này hoàn toàn defeat TLS security. Attacker có thể present fake certificate và client sẽ happily accept.&lt;/p&gt;
&lt;p&gt;Proper certificate validation check nhiều thứ: certificate chưa expire, issued bởi trusted CA, issued cho đúng domain (Common Name hoặc Subject Alternative Names match), certificate chain valid, certificate chưa bị revoke. Java&amp;rsquo;s default SSL implementation làm tất cả checks này, nhưng developers đôi khi disable vì &amp;ldquo;certificate errors&amp;rdquo; trong development.&lt;/p&gt;
&lt;p&gt;Better approach là use proper certificates ngay cả trong development. Let&amp;rsquo;s Encrypt provide free certificates, hoặc bạn có thể setup internal CA cho organization. Nếu thực sự cần self-signed certs trong dev, add chúng vào Java&amp;rsquo;s truststore thay vì disable validation hoàn toàn.&lt;/p&gt;
&lt;h2 id=&#34;certificate-pinning---extra-security-layer&#34;&gt;Certificate pinning - Extra security layer
&lt;/h2&gt;&lt;p&gt;Đối với high-security applications, certificate pinning provide thêm một layer protection. Thay vì trust bất kỳ CA nào trong system trust store, application chỉ accept certificates signed bởi specific CA hoặc chỉ accept một specific certificate.&lt;/p&gt;
&lt;p&gt;Concept là application &amp;ldquo;pin&amp;rdquo; expected certificate hoặc public key. Khi connect đến server, nếu presented certificate không match pinned certificate, connection bị reject ngay cả khi certificate valid theo normal validation rules.&lt;/p&gt;
&lt;p&gt;Trong Android development với Java/Kotlin:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CertificatePinner certificatePinner &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CertificatePinner.&lt;span style=&#34;color:#a6e22e&#34;&gt;Builder&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;api.example.com&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha256/AAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCC=&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OkHttpClient client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; OkHttpClient.&lt;span style=&#34;color:#a6e22e&#34;&gt;Builder&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;certificatePinner&lt;/span&gt;(certificatePinner)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Pinning protect khỏi compromised CAs. Nếu một CA bị hack và issue fake certificate cho &lt;code&gt;api.example.com&lt;/code&gt;, normal validation sẽ accept certificate đó. Nhưng với pinning, app detect rằng certificate không match pinned value và refuse connection.&lt;/p&gt;
&lt;p&gt;Downside của pinning là nó make certificate rotation khó hơn. Khi server certificate expire và được renew, pinned value change. Apps đã deployed sẽ fail connect. Bạn cần plan ahead, pin multiple certificates (current và backup), và update pins trước khi certificates expire.&lt;/p&gt;
&lt;h2 id=&#34;performance-considerations-của-tls&#34;&gt;Performance considerations của TLS
&lt;/h2&gt;&lt;p&gt;Một concern phổ biến về HTTPS là performance overhead. TLS handshake require additional round-trips, encryption/decryption consume CPU. Nhưng trong practice, overhead này minimal với modern hardware và optimized implementations.&lt;/p&gt;
&lt;p&gt;TLS 1.3, latest version, reduce handshake từ 2 round-trips xuống 1 round-trip so với TLS 1.2. Điều này cut latency đáng kể cho connection establishment. Session resumption cho phép clients reuse previous session keys, skip full handshake entirely cho subsequent connections.&lt;/p&gt;
&lt;p&gt;Modern CPUs có AES-NI (Advanced Encryption Standard New Instructions), hardware acceleration cho AES encryption. Với AES-NI, encryption overhead gần như negligible. Servers có thể handle thousands of TLS connections mà CPU usage chỉ tăng vài phần trăm.&lt;/p&gt;
&lt;p&gt;HTTP/2, which requires HTTPS trong most browser implementations, actually improve performance so với HTTP/1.1. Multiplexing, header compression, server push đều contribute đến faster page loads. Trong nhiều tests, HTTPS với HTTP/2 nhanh hơn HTTP thuần túy với HTTP/1.1.&lt;/p&gt;
&lt;p&gt;Google và các tech giants khác đã prove rằng HTTPS overhead không significant. Google report rằng switching Gmail sang HTTPS chỉ add dưới 1% server load và không noticeable impact lên user experience.&lt;/p&gt;
&lt;h2 id=&#34;https-không-còn-là-optional&#34;&gt;HTTPS không còn là optional
&lt;/h2&gt;&lt;p&gt;Năm 2018, Google Chrome bắt đầu mark tất cả HTTP sites là &amp;ldquo;Not Secure&amp;rdquo; trong address bar. Firefox, Safari, Edge đều follow suit. Users nhìn thấy warning rõ ràng khi visit HTTP sites. Điều này create incentive mạnh mẽ cho site owners migrate sang HTTPS.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s Encrypt, một free certificate authority, đã eliminate cost barrier của HTTPS. Certificate renewal có thể automated qua ACME protocol. Không còn excuse nào để không dùng HTTPS.&lt;/p&gt;
&lt;p&gt;Search engines như Google prioritize HTTPS sites trong rankings. HTTP sites bị penalize. Từ business perspective, không dùng HTTPS means mất traffic và revenue.&lt;/p&gt;
&lt;p&gt;Browser vendors đang dần deprecate features cho HTTP. Chrome đã announce rằng powerful features sẽ require secure contexts. Trong tương lai, có thể HTTP sẽ bị treat như deprecated protocol, chỉ dùng cho legacy systems.&lt;/p&gt;
&lt;p&gt;Từ góc nhìn developer, HTTPS phải là default choice. Khi bắt đầu project mới, setup HTTPS ngay từ đầu. Đừng đợi đến khi launch rồi mới migrate, vì migration có thể break things và require significant effort. Development environments nên mirror production càng nhiều càng tốt, include HTTPS.&lt;/p&gt;
&lt;h2 id=&#34;kết-luận&#34;&gt;Kết luận
&lt;/h2&gt;&lt;p&gt;HTTPS và TLS không phải là &amp;ldquo;extra feature&amp;rdquo; hay &amp;ldquo;nice to have&amp;rdquo;. Chúng là fundamental requirements cho bất kỳ ứng dụng web nào handle user data. Man-in-the-Middle attacks không phải là theoretical threats - chúng xảy ra mỗi ngày trên public WiFi networks, compromised routers, và malicious ISPs.&lt;/p&gt;
&lt;p&gt;HTTP expose mọi thứ dưới dạng plaintext. Passwords, personal information, session tokens - tất cả visible cho attackers. TLS encrypt communications, verify server identity, và ensure data integrity. Đây không phải là security theater, mà là essential protections mà users deserve.&lt;/p&gt;
&lt;p&gt;Trong Java applications, enabling TLS straightforward với keystores và SSL configurations. Browser security features increasingly require HTTPS, từ service workers đến powerful APIs. Performance overhead của TLS minimal và được offset bởi improvements như HTTP/2.&lt;/p&gt;
&lt;p&gt;Là developers, responsibility của chúng ta là protect user data. HTTPS là baseline minimum. Không implement HTTPS trong năm 2025 không chỉ là negligent mà còn potentially expose users đến attacks. Tools và infrastructure available để make HTTPS easy và free. Không còn lý do gì để không dùng nó.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Tham khảo:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RFC 8446 (TLS 1.3)&lt;/li&gt;
&lt;li&gt;OWASP Transport Layer Protection Cheat Sheet&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Bulletproof SSL and TLS&amp;rdquo; - Ivan Ristić&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s Encrypt Documentation&lt;/li&gt;
&lt;li&gt;MDN Web Security Documentation&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
