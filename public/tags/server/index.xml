<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Server on THUẬN AN IT BLOG</title>
    <link>http://localhost:1313/tags/server/</link>
    <description>Recent content in Server on THUẬN AN IT BLOG</description>
    <generator>Hugo</generator>
    <language>vi-vn</language>
    <lastBuildDate>Mon, 22 Dec 2025 01:30:00 +0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/server/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Từ Blocking I/O đến Non-blocking I/O: Java NIO thay đổi cách Server xử lý mạng như thế nào?</title>
      <link>http://localhost:1313/post/java-nio-blocking-nonblocking/</link>
      <pubDate>Mon, 22 Dec 2025 01:30:00 +0700</pubDate>
      <guid>http://localhost:1313/post/java-nio-blocking-nonblocking/</guid>
      <description>&lt;h2 id=&#34;khi-một-thread-chỉ-phục-vụ-một-kết-nối&#34;&gt;Khi một thread chỉ phục vụ một kết nối&lt;/h2&gt;&#xA;&lt;p&gt;Hồi mới bắt đầu viết server Java, mình làm theo mô hình đơn giản nhất: mỗi khi có client kết nối, tạo một thread mới để xử lý. ServerSocket accept connection, spawn một thread, thread đó đọc request, xử lý business logic, gửi response, rồi kết thúc. Nghe logic và dễ hiểu. Code cũng straightforward, không phức tạp gì.&lt;/p&gt;&#xA;&lt;p&gt;Vấn đề chỉ bộc lộ khi số lượng concurrent connections tăng lên. Với mô hình blocking I/O truyền thống, mỗi khi thread gọi &lt;code&gt;socket.read()&lt;/code&gt; hoặc &lt;code&gt;socket.write()&lt;/code&gt;, nó bị block cho đến khi operation hoàn thành. Nếu client chậm, network congested, hoặc đơn giản là client đang suy nghĩ, thread ở server cứ ngồi đó chờ. Không làm gì cả, chỉ chờ. CPU không tốn nhiều, nhưng thread thì chiếm memory và system resources.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
