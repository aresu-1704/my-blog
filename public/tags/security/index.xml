<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Security on Kiến thức lập trình</title>
        <link>http://localhost:1313/tags/security/</link>
        <description>Recent content in Security on Kiến thức lập trình</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>vi-vn</language>
        <lastBuildDate>Mon, 22 Dec 2025 01:20:00 +0700</lastBuildDate><atom:link href="http://localhost:1313/tags/security/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Bảo mật mạng trong ứng dụng Java &amp; JavaScript: từ HTTPS đến Man-in-the-Middle</title>
        <link>http://localhost:1313/post/https-mitm-security/</link>
        <pubDate>Mon, 22 Dec 2025 01:20:00 +0700</pubDate>
        
        <guid>http://localhost:1313/post/https-mitm-security/</guid>
        <description>&lt;img src="http://localhost:1313/images/https-security.jpg" alt="Featured image of post Bảo mật mạng trong ứng dụng Java &amp; JavaScript: từ HTTPS đến Man-in-the-Middle" /&gt;&lt;h2 id=&#34;https---hơn-cả-một-chữ-s&#34;&gt;HTTPS - Hơn cả một chữ S
&lt;/h2&gt;&lt;p&gt;Khi mình mới bắt đầu làm web, thường nghĩ HTTPS chỉ là HTTP thêm security, một feature &amp;ldquo;nice to have&amp;rdquo; cho các website ngân hàng hay e-commerce. Website blog cá nhân hay landing page đơn giản dùng HTTP cũng không sao. Nhưng càng đi sâu vào network security, mình mới thấy suy nghĩ đó ngây thơ đến mức nào.&lt;/p&gt;
&lt;p&gt;HTTPS không phải là một protocol riêng biệt. Nó chính là HTTP chạy bên trên một lớp bảo mật gọi là TLS (Transport Layer Security), trước đây gọi là SSL (Secure Sockets Layer). Về bản chất, khi bạn truy cập &lt;code&gt;https://example.com&lt;/code&gt;, trình duyệt không trực tiếp gửi HTTP request lên server. Thay vào đó, nó thiết lập một TLS connection trước, sau đó mới gửi HTTP data qua connection đã được mã hóa này.&lt;/p&gt;
&lt;p&gt;TLS hoạt động ở giữa tầng Transport (TCP) và tầng Application (HTTP). Nó tạo ra một encrypted tunnel cho data flow. Mọi thứ đi qua tunnel này đều được encrypt, từ HTTP headers đến request body, response data, cookies, tokens. Một observer trên network chỉ thấy được encrypted gibberish, không thể đọc được actual content.&lt;/p&gt;
&lt;h2 id=&#34;vì-sao-http-thuần-túy-nguy-hiểm&#34;&gt;Vì sao HTTP thuần túy nguy hiểm
&lt;/h2&gt;&lt;p&gt;HTTP là plaintext protocol. Khi bạn gửi request, mọi thứ được transmit dưới dạng text thuần túy qua network. Username, password, personal data, session tokens - tất cả đều visible cho bất kỳ ai có thể intercept network traffic.&lt;/p&gt;
&lt;p&gt;Hồi còn học đại học, mình từng dùng Wireshark để capture packets trên WiFi của trường. Chỉ trong vài phút, mình có thể thấy dozens of HTTP requests từ các bạn trong lớp. Một website không dùng HTTPS để login, mình thấy rõ username và password trong POST request body. Cookies của Facebook, session IDs của các forums - tất cả đều exposed.&lt;/p&gt;
&lt;p&gt;Điều đáng sợ là không cần phải là hacker để làm điều này. Bất kỳ ai ngồi chung WiFi công cộng với bạn đều có thể capture traffic. Starbucks, sân bay, hotel - những nơi này là goldmine cho attackers. Họ chỉ cần setup một WiFi access point với tên giống WiFi chính thức, đợi users connect vào, và passive capture mọi HTTP traffic.&lt;/p&gt;
&lt;h2 id=&#34;man-in-the-middle-attack---khi-kẻ-thứ-ba-chen-vào&#34;&gt;Man-in-the-Middle attack - Khi kẻ thứ ba chen vào
&lt;/h2&gt;&lt;p&gt;Man-in-the-Middle (MITM) attack còn nguy hiểm hơn passive sniffing. Trong attack này, attacker không chỉ observe traffic mà còn có thể modify nó. Họ đặt mình ở giữa client và server, intercept requests từ client, có thể modify rồi forward đến server. Tương tự, response từ server cũng đi qua attacker trước khi đến client.&lt;/p&gt;
&lt;p&gt;Cách hoạt động cụ thể như thế này. Giả sử bạn đang connect vào &lt;code&gt;http://bank.com&lt;/code&gt;. Request của bạn phải đi qua router, ISP, có thể qua nhiều intermediate hops trước khi đến server. Attacker có thể compromise bất kỳ hop nào trên đường đi này. Khi request đến attacker&amp;rsquo;s machine, họ có full access để đọc và modify.&lt;/p&gt;
&lt;p&gt;Một scenario phổ biến là ARP spoofing trên local network. Attacker gửi fake ARP messages để trick các devices nghĩ rằng attacker&amp;rsquo;s machine là gateway router. Mọi traffic từ victims đều route qua attacker&amp;rsquo;s machine trước. Attacker có thể thay đổi prices trong e-commerce requests, inject malicious scripts vào HTML responses, hoặc đơn giản là steal credentials.&lt;/p&gt;
&lt;p&gt;Với HTTP, không có cách nào để client verify rằng response thực sự đến từ legitimate server. Client gửi request đến IP address, nhận response từ IP đó, và trust response. Nhưng nếu attacker control routing hoặc DNS, họ có thể direct traffic đến fake server của họ. Client không có cách phân biệt.&lt;/p&gt;
&lt;h2 id=&#34;tls-và-certificate-chain-of-trust&#34;&gt;TLS và certificate chain of trust
&lt;/h2&gt;&lt;p&gt;TLS giải quyết vấn đề này thông qua cryptography và certificate authorities. Khi client connect đến HTTPS server, server phải present một digital certificate. Certificate này chứa public key của server và được sign bởi một trusted Certificate Authority (CA).&lt;/p&gt;
&lt;p&gt;Browser có built-in list of trusted CAs. Khi nhận certificate từ server, browser verify signature của CA. Nếu signature valid và CA nằm trong trusted list, browser tin rằng certificate authentic. Lúc này, client và server perform một key exchange protocol (thường là Diffie-Hellman hoặc RSA) để establish một shared secret. Shared secret này dùng để encrypt tất cả subsequent communication.&lt;/p&gt;
&lt;p&gt;Điều quan trọng là attacker không thể forge certificate. Để tạo valid certificate cho &lt;code&gt;bank.com&lt;/code&gt;, họ cần private key của một CA. Nhưng CAs protect private keys của họ vô cùng nghiêm ngặt. Nếu một CA bị compromise, modern browsers sẽ revoke trust đối với CA đó.&lt;/p&gt;
&lt;p&gt;Ngay cả khi attacker có thể intercept TLS traffic, họ chỉ thấy encrypted data. Không có private key của server, họ không thể decrypt. Nếu họ cố modify encrypted data, integrity checks sẽ fail và connection bị terminate. Client sẽ thấy error thay vì receive corrupted data.&lt;/p&gt;
&lt;h2 id=&#34;https-trong-java-server-applications&#34;&gt;HTTPS trong Java server applications
&lt;/h2&gt;&lt;p&gt;Khi develop Java backend, enable TLS là một phần thiết yếu của production setup. Java sử dụng keystores để manage certificates và private keys. Keystore là một encrypted file chứa certificates và keys, protected bởi password.&lt;/p&gt;
&lt;p&gt;Để setup HTTPS trong Java application server như Tomcat, bạn cần generate hoặc obtain một certificate. Trong development, bạn có thể tự generate self-signed certificate bằng keytool:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;keytool -genkeypair -alias myserver -keyalg RSA -keysize &lt;span style=&#34;color:#ae81ff&#34;&gt;2048&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -validity &lt;span style=&#34;color:#ae81ff&#34;&gt;365&lt;/span&gt; -keystore keystore.jks -storepass changeit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Command này tạo một RSA key pair và self-signed certificate, store chúng trong &lt;code&gt;keystore.jks&lt;/code&gt;. Trong production, thay vì self-signed cert, bạn sẽ request certificate từ một trusted CA như Let&amp;rsquo;s Encrypt, DigiCert, hoặc Comodo.&lt;/p&gt;
&lt;p&gt;Configure Tomcat để use keystore:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Connector&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;port=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;8443&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;protocol=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.apache.coyote.http11.Http11NioProtocol&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           &lt;span style=&#34;color:#a6e22e&#34;&gt;maxThreads=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;150&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SSLEnabled=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SSLHostConfig&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Certificate&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;certificateKeystoreFile=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;conf/keystore.jks&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#a6e22e&#34;&gt;certificateKeystorePassword=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;changeit&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#a6e22e&#34;&gt;type=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;RSA&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SSLHostConfig&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Connector&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Với Spring Boot, configuration còn đơn giản hơn trong &lt;code&gt;application.properties&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.port&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.ssl.key-store&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;classpath:keystore.jks&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.ssl.key-store-password&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;changeit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.ssl.key-store-type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;JKS&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;server.ssl.key-alias&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;myserver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Khi server start, Java&amp;rsquo;s SSL/TLS implementation (JSSE - Java Secure Socket Extension) handle toàn bộ TLS handshake, encryption và decryption. Application code của bạn không cần biết gì về underlying encryption. Bạn vẫn đọc request và gửi response như bình thường, JSSE transparent encrypt/decrypt ở phía dưới.&lt;/p&gt;
&lt;p&gt;Một best practice quan trọng là force HTTPS redirect. Nếu user accidentally access &lt;code&gt;http://example.com&lt;/code&gt;, server nên redirect đến &lt;code&gt;https://example.com&lt;/code&gt;. Trong Spring Security:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Configuration&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SecurityConfig&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; WebSecurityConfigurerAdapter {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;configure&lt;/span&gt;(HttpSecurity http) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        http.&lt;span style=&#34;color:#a6e22e&#34;&gt;requiresChannel&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .&lt;span style=&#34;color:#a6e22e&#34;&gt;anyRequest&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .&lt;span style=&#34;color:#a6e22e&#34;&gt;requiresSecure&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// Force HTTPS&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;javascript-và-browser-security-restrictions&#34;&gt;JavaScript và browser security restrictions
&lt;/h2&gt;&lt;p&gt;Phía client, JavaScript trong browser cũng có những restrictions nghiêm ngặt liên quan đến HTTPS. Modern browsers implement nhiều security features chỉ available khi page được serve qua HTTPS.&lt;/p&gt;
&lt;p&gt;Service Workers, một technology cho Progressive Web Apps và offline functionality, hoàn toàn require HTTPS. Browser không cho register service workers từ HTTP pages (except localhost cho development). Lý do là service workers có quyền intercept network requests và modify responses. Nếu attacker có thể inject malicious service worker qua HTTP, họ có thể control toàn bộ subsequent requests của user.&lt;/p&gt;
&lt;p&gt;Geolocation API, camera và microphone access, clipboard API, payment request API - tất cả đều require HTTPS. Browser không muốn sensitive permissions này được grant cho potentially insecure pages. Nếu page được serve qua HTTP, attacker có thể modify JavaScript để abuse những permissions này.&lt;/p&gt;
&lt;p&gt;Cookies với flag &lt;code&gt;Secure&lt;/code&gt; chỉ được gửi qua HTTPS connections. Đây là cách protect session cookies khỏi being stolen qua HTTP. Khi set cookie:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;document.&lt;span style=&#34;color:#a6e22e&#34;&gt;cookie&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sessionId=abc123; Secure; HttpOnly; SameSite=Strict&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Flag &lt;code&gt;Secure&lt;/code&gt; ensure rằng ngay cả khi user accidentally truy cập HTTP version của site, session cookie sẽ không được gửi. &lt;code&gt;HttpOnly&lt;/code&gt; prevent JavaScript access (protect khỏi XSS), và &lt;code&gt;SameSite=Strict&lt;/code&gt; prevent cookie được gửi trong cross-site requests (protect khỏi CSRF).&lt;/p&gt;
&lt;p&gt;HTTP Strict Transport Security (HSTS) là một mechanism mà server có thể tell browser &amp;ldquo;luôn luôn dùng HTTPS cho domain này&amp;rdquo;. Server gửi header:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Strict-Transport-Security: max-age=31536000; includeSubDomains
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Browser sẽ remember directive này trong 31536000 seconds (1 năm). Trong thời gian đó, mọi attempt truy cập HTTP version sẽ automatically redirect sang HTTPS ngay ở browser, không cần round-trip đến server. Điều này prevent một loại MITM attack gọi là SSL stripping, where attacker downgrade HTTPS connections sang HTTP.&lt;/p&gt;
&lt;h2 id=&#34;mixed-content-và-browser-warnings&#34;&gt;Mixed content và browser warnings
&lt;/h2&gt;&lt;p&gt;Một vấn đề phổ biến khi migrate từ HTTP sang HTTPS là mixed content. Nếu HTTPS page load resources (scripts, stylesheets, images) qua HTTP, browser sẽ block hoặc warn. Lý do là ngay cả khi main page secure, HTTP resources có thể bị modified bởi attacker, compromise toàn bộ page.&lt;/p&gt;
&lt;p&gt;Ví dụ, nếu HTTPS page include:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://cdn.example.com/jquery.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Browser sẽ block script này. Attacker có thể MITM connection đến CDN và inject malicious code vào jQuery. Dù main page được deliver securely, injected script có full access để steal data.&lt;/p&gt;
&lt;p&gt;Modern browsers classify mixed content thành hai loại. Passive mixed content (images, audio, video) được load nhưng có warning. Active mixed content (scripts, stylesheets, fonts) bị block hoàn toàn. Để fix, bạn phải đảm bảo tất cả resources loaded qua HTTPS hoặc use protocol-relative URLs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;//cdn.example.com/jquery.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Protocol-relative URLs inherit protocol của parent page. Nếu page là HTTPS, resource cũng được load qua HTTPS.&lt;/p&gt;
&lt;h2 id=&#34;certificate-validation-và-trust-issues&#34;&gt;Certificate validation và trust issues
&lt;/h2&gt;&lt;p&gt;Mặc dù TLS provide strong security, nó rely on certificate validation. Nếu client không properly validate certificates, security bị compromise. Một mistake phổ biến trong Java code là disable certificate validation trong development rồi quên enable lại trong production.&lt;/p&gt;
&lt;p&gt;Mình từng thấy code như này trong production:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// DANGER: Disable certificate validation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TrustManager&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; trustAllCerts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TrustManager&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; X509TrustManager() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; X509Certificate&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getAcceptedIssuers&lt;/span&gt;() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkClientTrusted&lt;/span&gt;(X509Certificate&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; certs, String authType) {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkServerTrusted&lt;/span&gt;(X509Certificate&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; certs, String authType) {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SSLContext sc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SSLContext.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SSL&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sc.&lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;, trustAllCerts, &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; java.&lt;span style=&#34;color:#a6e22e&#34;&gt;security&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SecureRandom&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HttpsURLConnection.&lt;span style=&#34;color:#a6e22e&#34;&gt;setDefaultSSLSocketFactory&lt;/span&gt;(sc.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSocketFactory&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Code này accept bất kỳ certificate nào, kể cả self-signed hay expired certs. Điều này hoàn toàn defeat TLS security. Attacker có thể present fake certificate và client sẽ happily accept.&lt;/p&gt;
&lt;p&gt;Proper certificate validation check nhiều thứ: certificate chưa expire, issued bởi trusted CA, issued cho đúng domain (Common Name hoặc Subject Alternative Names match), certificate chain valid, certificate chưa bị revoke. Java&amp;rsquo;s default SSL implementation làm tất cả checks này, nhưng developers đôi khi disable vì &amp;ldquo;certificate errors&amp;rdquo; trong development.&lt;/p&gt;
&lt;p&gt;Better approach là use proper certificates ngay cả trong development. Let&amp;rsquo;s Encrypt provide free certificates, hoặc bạn có thể setup internal CA cho organization. Nếu thực sự cần self-signed certs trong dev, add chúng vào Java&amp;rsquo;s truststore thay vì disable validation hoàn toàn.&lt;/p&gt;
&lt;h2 id=&#34;certificate-pinning---extra-security-layer&#34;&gt;Certificate pinning - Extra security layer
&lt;/h2&gt;&lt;p&gt;Đối với high-security applications, certificate pinning provide thêm một layer protection. Thay vì trust bất kỳ CA nào trong system trust store, application chỉ accept certificates signed bởi specific CA hoặc chỉ accept một specific certificate.&lt;/p&gt;
&lt;p&gt;Concept là application &amp;ldquo;pin&amp;rdquo; expected certificate hoặc public key. Khi connect đến server, nếu presented certificate không match pinned certificate, connection bị reject ngay cả khi certificate valid theo normal validation rules.&lt;/p&gt;
&lt;p&gt;Trong Android development với Java/Kotlin:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CertificatePinner certificatePinner &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CertificatePinner.&lt;span style=&#34;color:#a6e22e&#34;&gt;Builder&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;api.example.com&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha256/AAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCC=&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OkHttpClient client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; OkHttpClient.&lt;span style=&#34;color:#a6e22e&#34;&gt;Builder&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;certificatePinner&lt;/span&gt;(certificatePinner)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Pinning protect khỏi compromised CAs. Nếu một CA bị hack và issue fake certificate cho &lt;code&gt;api.example.com&lt;/code&gt;, normal validation sẽ accept certificate đó. Nhưng với pinning, app detect rằng certificate không match pinned value và refuse connection.&lt;/p&gt;
&lt;p&gt;Downside của pinning là nó make certificate rotation khó hơn. Khi server certificate expire và được renew, pinned value change. Apps đã deployed sẽ fail connect. Bạn cần plan ahead, pin multiple certificates (current và backup), và update pins trước khi certificates expire.&lt;/p&gt;
&lt;h2 id=&#34;performance-considerations-của-tls&#34;&gt;Performance considerations của TLS
&lt;/h2&gt;&lt;p&gt;Một concern phổ biến về HTTPS là performance overhead. TLS handshake require additional round-trips, encryption/decryption consume CPU. Nhưng trong practice, overhead này minimal với modern hardware và optimized implementations.&lt;/p&gt;
&lt;p&gt;TLS 1.3, latest version, reduce handshake từ 2 round-trips xuống 1 round-trip so với TLS 1.2. Điều này cut latency đáng kể cho connection establishment. Session resumption cho phép clients reuse previous session keys, skip full handshake entirely cho subsequent connections.&lt;/p&gt;
&lt;p&gt;Modern CPUs có AES-NI (Advanced Encryption Standard New Instructions), hardware acceleration cho AES encryption. Với AES-NI, encryption overhead gần như negligible. Servers có thể handle thousands of TLS connections mà CPU usage chỉ tăng vài phần trăm.&lt;/p&gt;
&lt;p&gt;HTTP/2, which requires HTTPS trong most browser implementations, actually improve performance so với HTTP/1.1. Multiplexing, header compression, server push đều contribute đến faster page loads. Trong nhiều tests, HTTPS với HTTP/2 nhanh hơn HTTP thuần túy với HTTP/1.1.&lt;/p&gt;
&lt;p&gt;Google và các tech giants khác đã prove rằng HTTPS overhead không significant. Google report rằng switching Gmail sang HTTPS chỉ add dưới 1% server load và không noticeable impact lên user experience.&lt;/p&gt;
&lt;h2 id=&#34;https-không-còn-là-optional&#34;&gt;HTTPS không còn là optional
&lt;/h2&gt;&lt;p&gt;Năm 2018, Google Chrome bắt đầu mark tất cả HTTP sites là &amp;ldquo;Not Secure&amp;rdquo; trong address bar. Firefox, Safari, Edge đều follow suit. Users nhìn thấy warning rõ ràng khi visit HTTP sites. Điều này create incentive mạnh mẽ cho site owners migrate sang HTTPS.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s Encrypt, một free certificate authority, đã eliminate cost barrier của HTTPS. Certificate renewal có thể automated qua ACME protocol. Không còn excuse nào để không dùng HTTPS.&lt;/p&gt;
&lt;p&gt;Search engines như Google prioritize HTTPS sites trong rankings. HTTP sites bị penalize. Từ business perspective, không dùng HTTPS means mất traffic và revenue.&lt;/p&gt;
&lt;p&gt;Browser vendors đang dần deprecate features cho HTTP. Chrome đã announce rằng powerful features sẽ require secure contexts. Trong tương lai, có thể HTTP sẽ bị treat như deprecated protocol, chỉ dùng cho legacy systems.&lt;/p&gt;
&lt;p&gt;Từ góc nhìn developer, HTTPS phải là default choice. Khi bắt đầu project mới, setup HTTPS ngay từ đầu. Đừng đợi đến khi launch rồi mới migrate, vì migration có thể break things và require significant effort. Development environments nên mirror production càng nhiều càng tốt, include HTTPS.&lt;/p&gt;
&lt;h2 id=&#34;kết-luận&#34;&gt;Kết luận
&lt;/h2&gt;&lt;p&gt;HTTPS và TLS không phải là &amp;ldquo;extra feature&amp;rdquo; hay &amp;ldquo;nice to have&amp;rdquo;. Chúng là fundamental requirements cho bất kỳ ứng dụng web nào handle user data. Man-in-the-Middle attacks không phải là theoretical threats - chúng xảy ra mỗi ngày trên public WiFi networks, compromised routers, và malicious ISPs.&lt;/p&gt;
&lt;p&gt;HTTP expose mọi thứ dưới dạng plaintext. Passwords, personal information, session tokens - tất cả visible cho attackers. TLS encrypt communications, verify server identity, và ensure data integrity. Đây không phải là security theater, mà là essential protections mà users deserve.&lt;/p&gt;
&lt;p&gt;Trong Java applications, enabling TLS straightforward với keystores và SSL configurations. Browser security features increasingly require HTTPS, từ service workers đến powerful APIs. Performance overhead của TLS minimal và được offset bởi improvements như HTTP/2.&lt;/p&gt;
&lt;p&gt;Là developers, responsibility của chúng ta là protect user data. HTTPS là baseline minimum. Không implement HTTPS trong năm 2025 không chỉ là negligent mà còn potentially expose users đến attacks. Tools và infrastructure available để make HTTPS easy và free. Không còn lý do gì để không dùng nó.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Tham khảo:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RFC 8446 (TLS 1.3)&lt;/li&gt;
&lt;li&gt;OWASP Transport Layer Protection Cheat Sheet&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Bulletproof SSL and TLS&amp;rdquo; - Ivan Ristić&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s Encrypt Documentation&lt;/li&gt;
&lt;li&gt;MDN Web Security Documentation&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>CORS và Same-Origin Policy dưới góc nhìn mạng máy tính (JavaScript)</title>
        <link>http://localhost:1313/post/cors-same-origin-policy/</link>
        <pubDate>Mon, 22 Dec 2025 01:11:00 +0700</pubDate>
        
        <guid>http://localhost:1313/post/cors-same-origin-policy/</guid>
        <description>&lt;img src="http://localhost:1313/images/cors.jpg" alt="Featured image of post CORS và Same-Origin Policy dưới góc nhìn mạng máy tính (JavaScript)" /&gt;&lt;h2 id=&#34;khi-trình-duyệt-trở-thành-bức-tường-bảo-vệ&#34;&gt;Khi trình duyệt trở thành bức tường bảo vệ
&lt;/h2&gt;&lt;p&gt;Hồi mới học web development, mình thường gặp lỗi này khi gọi API từ frontend: &amp;ldquo;Access to fetch at &amp;lsquo;&lt;a class=&#34;link&#34; href=&#34;https://api.example.com&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://api.example.com&lt;/a&gt;&amp;rsquo; from origin &amp;lsquo;http://localhost:3000&amp;rsquo; has been blocked by CORS policy&amp;rdquo;. Lúc đầu nghĩ đây là lỗi code, sửa mãi không được. Rồi mình test API bằng Postman thì thấy nó chạy ngon lành. Càng confused hơn, API hoạt động tốt mà sao trình duyệt lại chặn?&lt;/p&gt;
&lt;p&gt;Câu trả lời nằm ở chỗ trình duyệt không phải là một HTTP client thông thường như Postman hay curl. Trình duyệt là một môi trường thực thi code với quyền truy cập vào cookies, localStorage, session tokens của người dùng. Nếu không có cơ chế bảo mật, bất kỳ website nào cũng có thể chạy JavaScript để đánh cắp dữ liệu từ các site khác mà user đang đăng nhập.&lt;/p&gt;
&lt;h2 id=&#34;same-origin-policy---nền-tảng-bảo-mật-web&#34;&gt;Same-Origin Policy - Nền tảng bảo mật web
&lt;/h2&gt;&lt;p&gt;Same-Origin Policy ra đời từ những ngày đầu của web để ngăn chặn một website đọc dữ liệu từ website khác. Hai URL được coi là cùng origin nếu chúng có cùng protocol, domain và port. Ví dụ, &lt;code&gt;https://example.com:443/page1&lt;/code&gt; và &lt;code&gt;https://example.com:443/page2&lt;/code&gt; là cùng origin. Nhưng &lt;code&gt;https://example.com&lt;/code&gt; và &lt;code&gt;http://example.com&lt;/code&gt; khác origin vì protocol khác nhau. Tương tự, &lt;code&gt;https://example.com&lt;/code&gt; và &lt;code&gt;https://api.example.com&lt;/code&gt; cũng khác origin vì subdomain khác nhau.&lt;/p&gt;
&lt;p&gt;Chính sách này nghe có vẻ strict, nhưng hãy tưởng tượng kịch bản sau. Bạn đang đăng nhập vào ngân hàng ở tab này, session cookie được lưu trong browser. Sau đó bạn vào một website độc hại ở tab khác. Nếu không có Same-Origin Policy, website đó có thể chạy JavaScript để gửi request đến &lt;code&gt;https://bank.com/api/transfer&lt;/code&gt; với credentials của bạn. Vì cookies được tự động gửi kèm trong mỗi request đến cùng domain, ngân hàng sẽ nghĩ đây là request hợp lệ từ bạn và thực hiện chuyển tiền.&lt;/p&gt;
&lt;p&gt;Đây chính là CSRF (Cross-Site Request Forgery) attack. Same-Origin Policy ngăn chặn scenario này bằng cách không cho phép JavaScript từ &lt;code&gt;evil.com&lt;/code&gt; đọc response từ &lt;code&gt;bank.com&lt;/code&gt;. Request vẫn được gửi đi (vì HTTP protocol không biết gì về origins), nhưng trình duyệt sẽ chặn JavaScript access vào response data.&lt;/p&gt;
&lt;p&gt;Điểm quan trọng cần hiểu là Same-Origin Policy được implement ở tầng ứng dụng bởi trình duyệt, không phải ở network layer hay transport layer. Nếu nhìn qua mô hình OSI, HTTP request vẫn đi qua các tầng Physical, Data Link, Network, Transport một cách bình thường. Server nhận request, xử lý và gửi response về. Nhưng khi response về đến browser (tầng Application), browser kiểm tra origin và quyết định có cho phép JavaScript access hay không.&lt;/p&gt;
&lt;h2 id=&#34;vấn-đề-với-modern-web-applications&#34;&gt;Vấn đề với modern web applications
&lt;/h2&gt;&lt;p&gt;Thời đầu web, các trang đều static HTML được serve từ cùng một domain. Same-Origin Policy hoạt động hoàn hảo. Nhưng modern architecture lại khác. Frontend chạy trên &lt;code&gt;https://app.example.com&lt;/code&gt;, backend API ở &lt;code&gt;https://api.example.com&lt;/code&gt;, CDN serving assets từ &lt;code&gt;https://cdn.example.com&lt;/code&gt;. Đây là các origins khác nhau, và Same-Origin Policy sẽ block tất cả.&lt;/p&gt;
&lt;p&gt;Mình từng làm một project mà frontend được deploy lên Netlify (&lt;code&gt;https://myapp.netlify.app&lt;/code&gt;) còn backend API chạy trên Heroku (&lt;code&gt;https://myapi.herokuapp.com&lt;/code&gt;). Khi frontend gọi API, browser ngay lập tức block với CORS error. Đây không phải là lỗi của code, mà là Same-Origin Policy đang làm đúng nhiệm vụ bảo vệ. Vấn đề là làm sao để cho phép cross-origin requests một cách có kiểm soát?&lt;/p&gt;
&lt;h2 id=&#34;cors---cơ-chế-nới-lỏng-có-kiểm-soát&#34;&gt;CORS - Cơ chế nới lỏng có kiểm soát
&lt;/h2&gt;&lt;p&gt;CORS (Cross-Origin Resource Sharing) ra đời như một mechanism để server có thể explicit cho phép requests từ origins khác. Ý tưởng đơn giản: server gửi các headers đặc biệt trong response để báo cho browser biết &amp;ldquo;origin này được phép truy cập resource của tôi&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Header quan trọng nhất là &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;. Khi server gửi header này trong response, browser sẽ kiểm tra xem origin của request có match với value trong header không. Nếu match, JavaScript được phép access response. Nếu không match, browser block access.&lt;/p&gt;
&lt;p&gt;Ví dụ, khi frontend ở &lt;code&gt;https://app.example.com&lt;/code&gt; gọi API ở &lt;code&gt;https://api.example.com&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Frontend code chạy trên https://app.example.com
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://api.example.com/users&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CORS error:&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Browser sẽ gửi request với header &lt;code&gt;Origin: https://app.example.com&lt;/code&gt;. Server nhận request, xử lý, và trả về response kèm header:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Access-Control-Allow-Origin: https://app.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Browser thấy origin match, cho phép JavaScript access data. Simple và hiệu quả.&lt;/p&gt;
&lt;h2 id=&#34;preflight-request---bước-kiểm-tra-an-toàn&#34;&gt;Preflight request - Bước kiểm tra an toàn
&lt;/h2&gt;&lt;p&gt;Nhưng có một điều thú vị. Đối với một số loại requests, browser không gửi actual request ngay lập tức. Thay vào đó, nó gửi một &amp;ldquo;preflight&amp;rdquo; request dùng method OPTIONS để hỏi server &amp;ldquo;tôi muốn gửi request này, bạn có cho phép không?&amp;rdquo;. Server phải respond với các CORS headers thích hợp, browser mới gửi actual request.&lt;/p&gt;
&lt;p&gt;Preflight request xảy ra khi request không phải là &amp;ldquo;simple request&amp;rdquo;. Simple request phải thỏa mãn tất cả các điều kiện sau: method phải là GET, HEAD hoặc POST; không có custom headers ngoài một số headers được cho phép như Content-Type, Accept; nếu có Content-Type thì phải là &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt; hoặc &lt;code&gt;text/plain&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Nghe phức tạp, nhưng về cơ bản, nếu bạn gửi JSON với &lt;code&gt;Content-Type: application/json&lt;/code&gt; hoặc thêm custom header như &lt;code&gt;Authorization: Bearer token&lt;/code&gt;, request không còn &amp;ldquo;simple&amp;rdquo; nữa. Browser sẽ gửi preflight.&lt;/p&gt;
&lt;p&gt;Tại sao lại cần preflight? Lý do là để protect legacy servers. Trước khi CORS ra đời, nhiều servers được build với giả định rằng chỉ same-origin requests mới đến được. Nếu browser cho phép cross-origin requests với methods như PUT, DELETE hoặc custom headers mà không kiểm tra trước, những servers này có thể bị attack. Preflight request cho server cơ hội từ chối trước khi actual request được gửi.&lt;/p&gt;
&lt;p&gt;Ví dụ khi gửi JSON:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Request này sẽ trigger preflight
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://api.example.com/users&amp;#39;&lt;/span&gt;, {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;POST&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;headers&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;application/json&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Authorization&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Bearer mytoken123&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;JSON&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;stringify&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;John&amp;#39;&lt;/span&gt; })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Browser sẽ gửi preflight request trước:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;OPTIONS /users HTTP/1.1
Host: api.example.com
Origin: https://app.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type, Authorization
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Server phải respond:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 86400
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt; cho browser biết có thể cache preflight response trong 86400 giây (24 giờ). Trong thời gian này, browser không cần gửi preflight lại cho cùng loại request, giảm overhead.&lt;/p&gt;
&lt;h2 id=&#34;tại-sao-postman-không-gặp-cors&#34;&gt;Tại sao Postman không gặp CORS
&lt;/h2&gt;&lt;p&gt;Đây là câu hỏi mình hay gặp nhất. API chạy tốt trên Postman nhưng lại CORS error trên browser. Nguyên nhân đơn giản: Postman không phải là trình duyệt web. Nó là một HTTP client thuần túy, không implement Same-Origin Policy.&lt;/p&gt;
&lt;p&gt;Khi bạn gửi request từ Postman, nó chỉ đơn giản là tạo HTTP request, gửi đi, nhận response và hiển thị. Không có khái niệm &amp;ldquo;origin&amp;rdquo;, không có security restrictions. Postman không chạy JavaScript từ websites mà user đang browse, nên không cần bảo vệ user khỏi malicious scripts.&lt;/p&gt;
&lt;p&gt;Còn browser thì khác. Browser là một platform chạy code từ bất kỳ website nào user visit. Nếu không có Same-Origin Policy và CORS, một website độc hại có thể exploit browser để truy cập dữ liệu từ các sites khác, sử dụng cookies và credentials của user. Browser phải assume rằng mọi website đều potentially malicious và áp dụng các restrictions tương ứng.&lt;/p&gt;
&lt;p&gt;Đây cũng là lý do tại sao backend developers thường confused về CORS. Khi họ test API bằng curl hoặc Postman, mọi thứ work perfectly. Nhưng khi frontend team integrate, lại báo CORS errors. Đó không phải lỗi của API code, mà là vì API chưa được config để accept cross-origin requests từ browser.&lt;/p&gt;
&lt;h2 id=&#34;cors-trong-kiến-trúc-phân-tầng&#34;&gt;CORS trong kiến trúc phân tầng
&lt;/h2&gt;&lt;p&gt;Để hiểu rõ hơn vị trí của CORS trong stack, hãy nhìn vào mô hình OSI. HTTP request bắt đầu từ tầng Application (tầng 7), đi xuống qua Presentation, Session, Transport (TCP), Network (IP), Data Link, và cuối cùng là Physical layer. Data được encode, packet-ized, routed và transmitted qua network.&lt;/p&gt;
&lt;p&gt;Ở phía server, request đi ngược lại từ Physical lên Application. Server process request ở tầng Application, generate response và gửi xuống ngược lại. Response travel qua các tầng giống như request.&lt;/p&gt;
&lt;p&gt;Same-Origin Policy và CORS hoạt động hoàn toàn ở tầng Application, specifically là ở browser runtime. Network layers bên dưới không biết gì về origins hay CORS. TCP connection được establish bình thường, HTTP request được gửi và nhận response thành công. Chỉ khi response về đến browser, JavaScript runtime mới kiểm tra CORS headers và quyết định có expose response cho script hay không.&lt;/p&gt;
&lt;p&gt;Điều này giải thích tại sao bạn có thể thấy request thành công trong Network tab của DevTools (vì request đã đến server và nhận về response ở HTTP level), nhưng JavaScript vẫn báo lỗi CORS (vì browser block access ở Application level).&lt;/p&gt;
&lt;h2 id=&#34;implement-cors-ở-backend&#34;&gt;Implement CORS ở backend
&lt;/h2&gt;&lt;p&gt;Việc enable CORS ở backend khá straightforward nhưng cần cẩn thận. Nhiều developers để &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; cho tiện, nhưng đây là security risk. Wildcard cho phép mọi origin access API của bạn, kể cả các malicious sites.&lt;/p&gt;
&lt;p&gt;Better practice là explicitly list allowed origins. Nếu bạn có nhiều environments (dev, staging, production), maintain một whitelist:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Node.js/Express example
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;allowedOrigins&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://app.example.com&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://staging.example.com&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://localhost:3000&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Development
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;use&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;origin&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;headers&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;origin&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;allowedOrigins&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;includes&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;origin&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setHeader&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Access-Control-Allow-Origin&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;origin&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setHeader&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Access-Control-Allow-Methods&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET, POST, PUT, DELETE, OPTIONS&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setHeader&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Access-Control-Allow-Headers&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Content-Type, Authorization&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setHeader&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Access-Control-Allow-Credentials&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;true&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setHeader&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Access-Control-Max-Age&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;86400&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Handle preflight
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;OPTIONS&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;sendStatus&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;204&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Header &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; cần đặc biệt chú ý. Nếu set &lt;code&gt;true&lt;/code&gt;, browser sẽ include cookies và authorization headers trong cross-origin requests. Nhưng khi enable credentials, bạn không thể dùng wildcard &lt;code&gt;*&lt;/code&gt; cho Allow-Origin, phải specify exact origin.&lt;/p&gt;
&lt;p&gt;Trong Java Spring Boot, config còn đơn giản hơn:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Configuration&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CorsConfig&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; WebMvcConfigurer {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addCorsMappings&lt;/span&gt;(CorsRegistry registry) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        registry.&lt;span style=&#34;color:#a6e22e&#34;&gt;addMapping&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/api/**&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;allowedOrigins&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://app.example.com&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:3000&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;allowedMethods&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;POST&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PUT&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DELETE&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OPTIONS&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;allowedHeaders&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Authorization&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;allowCredentials&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;maxAge&lt;/span&gt;(86400);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;debugging-cors-issues&#34;&gt;Debugging CORS issues
&lt;/h2&gt;&lt;p&gt;Khi gặp CORS errors, bước đầu tiên là mở DevTools Network tab. Tìm request bị block và check cả request headers lẫn response headers. Request phải có header &lt;code&gt;Origin&lt;/code&gt;, còn response phải có &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Nếu thấy preflight request (method OPTIONS) failed, nghĩa là server chưa handle preflight đúng cách. Server phải respond với status 200 hoặc 204 và include tất cả CORS headers cần thiết.&lt;/p&gt;
&lt;p&gt;Một trick mình hay dùng là temporary disable CORS ở browser để verify rằng vấn đề thực sự là CORS chứ không phải lỗi khác. Chrome có thể start với flag &lt;code&gt;--disable-web-security&lt;/code&gt;. Nhưng nhớ rằng đây chỉ để debug, never dùng trong production.&lt;/p&gt;
&lt;p&gt;Nếu API của bạn phía sau proxy hoặc load balancer, đảm bảo rằng CORS headers không bị strip đi. Một số proxies có default config remove certain headers. Bạn cần config proxy để preserve CORS headers hoặc thêm headers ở proxy level.&lt;/p&gt;
&lt;h2 id=&#34;cors-với-credentials-và-authentication&#34;&gt;CORS với credentials và authentication
&lt;/h2&gt;&lt;p&gt;Khi làm việc với authenticated APIs, CORS trở nên phức tạp hơn một chút. Nếu API yêu cầu authentication token trong header (ví dụ JWT), frontend phải include credentials trong fetch request:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://api.example.com/protected&amp;#39;&lt;/span&gt;, {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;credentials&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;include&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// Quan trọng!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;headers&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Authorization&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Bearer &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;application/json&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Setting &lt;code&gt;credentials: &#39;include&#39;&lt;/code&gt; tells browser gửi cookies và authorization headers. Server phải respond với &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; và một specific origin (không được dùng wildcard).&lt;/p&gt;
&lt;p&gt;Một pattern hay gặp là dùng cookies cho session management. Browser automatically gửi cookies trong mọi request đến domain đó, kể cả cross-origin requests. Nhưng với CORS, cookies chỉ được gửi nếu &lt;code&gt;credentials: &#39;include&#39;&lt;/code&gt; ở client và &lt;code&gt;Allow-Credentials: true&lt;/code&gt; ở server. Đây là layer bảo vệ thêm để prevent accidental credential leakage.&lt;/p&gt;
&lt;h2 id=&#34;cors-không-phải-silver-bullet&#34;&gt;CORS không phải silver bullet
&lt;/h2&gt;&lt;p&gt;Quan trọng là hiểu rằng CORS không phải là security feature cho backend. Nó là một browser security mechanism để protect users. Backend vẫn phải implement proper authentication và authorization. Việc một request pass được CORS check không có nghĩa là request đó legitimate.&lt;/p&gt;
&lt;p&gt;Hacker có thể bypass CORS bằng cách gửi requests từ server-side code (không qua browser) hoặc dùng proxy. CORS chỉ prevent malicious websites từ việc sử dụng browser của user để attack. Nó không protect API khỏi direct attacks.&lt;/p&gt;
&lt;p&gt;Vì thế, backend phải luôn validate requests, check authentication tokens, verify permissions. CORS chỉ là một layer trong defense-in-depth strategy, không phải là duy nhất.&lt;/p&gt;
&lt;h2 id=&#34;security-considerations&#34;&gt;Security considerations
&lt;/h2&gt;&lt;p&gt;Khi config CORS, easy mistake là quá permissive. Setting &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; tiện lợi nhưng nguy hiểm. Bất kỳ website nào cũng có thể call API của bạn từ browser. Nếu API không require authentication, data có thể bị leaked.&lt;/p&gt;
&lt;p&gt;Worse hơn, nếu bạn set wildcard và enable credentials cùng lúc, browser sẽ reject (thankfully). Nhưng nhiều developers thấy error rồi fix bằng cách allow specific origin trong code nhưng vẫn check origin không cẩn thận, leading to bypass opportunities.&lt;/p&gt;
&lt;p&gt;Một attack vector là subdomain takeover. Nếu bạn allow &lt;code&gt;*.example.com&lt;/code&gt;, attacker có thể takeover một abandoned subdomain và sử dụng nó để call API với valid origin. Better practice là whitelist exact subdomains bạn control.&lt;/p&gt;
&lt;p&gt;Reflect origin từ request header vào response cũng nguy hiểm. Nếu code chỉ đơn giản là &lt;code&gt;res.setHeader(&#39;Access-Control-Allow-Origin&#39;, req.headers.origin)&lt;/code&gt;, bất kỳ origin nào cũng qua. Phải validate origin against whitelist trước.&lt;/p&gt;
&lt;h2 id=&#34;kết-luận&#34;&gt;Kết luận
&lt;/h2&gt;&lt;p&gt;Same-Origin Policy và CORS thường bị hiểu lầm là &amp;ldquo;lỗi phiền phức&amp;rdquo; của web development. Nhưng thực ra chúng là những mechanisms quan trọng bảo vệ users khỏi cross-site attacks. Hiểu rõ cách chúng hoạt động ở tầng mạng và browser runtime giúp bạn không chỉ fix CORS errors mà còn design secure APIs.&lt;/p&gt;
&lt;p&gt;CORS không hoạt động ở network layer hay transport layer. Nó là một tầng bảo mật ở application layer, được implement bởi browsers để kiểm soát cross-origin access. Server express consent thông qua CORS headers, browser enforce policies đó. Postman và các HTTP clients khác không gặp CORS vì chúng không chạy trong browser security context.&lt;/p&gt;
&lt;p&gt;Khi implement CORS, hãy balance giữa usability và security. Quá strict làm development khó khăn, quá permissive tạo security holes. Whitelist specific origins, validate requests properly, và test thoroughly ở tất cả environments. CORS errors thường là dấu hiệu rằng bạn đang làm đúng - browser đang protect users. Nhiệm vụ của developer là config properly để legitimate requests pass qua nhưng malicious requests bị block.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Tham khảo:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MDN Web Docs: Same-Origin Policy &amp;amp; CORS&lt;/li&gt;
&lt;li&gt;OWASP CORS Security Cheat Sheet&lt;/li&gt;
&lt;li&gt;RFC 6454: The Web Origin Concept&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Web Security Academy&amp;rdquo; - PortSwigger&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
